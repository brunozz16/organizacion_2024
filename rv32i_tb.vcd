$date
	Wed Nov 13 10:23:31 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module rv32i_tb $end
$var wire 32 ! pc [31:0] $end
$var reg 1 " clk $end
$var reg 32 # instruction [31:0] $end
$var reg 1 $ reset $end
$scope module uut $end
$var wire 1 " clk $end
$var wire 32 % instruction [31:0] $end
$var wire 1 $ reset $end
$var wire 1 & zero $end
$var wire 32 ' writeData [31:0] $end
$var wire 2 ( resSrc [1:0] $end
$var wire 1 ) regWrite $end
$var wire 1 * pcSrc $end
$var wire 32 + pc [31:0] $end
$var wire 1 , memWrite $end
$var wire 2 - inmSrc [1:0] $end
$var wire 1 . branch $end
$var wire 1 / aluSrc $end
$var wire 32 0 aluResult [31:0] $end
$var wire 3 1 ALUcontrol [2:0] $end
$scope module control_unit $end
$var wire 1 / aluSrc $end
$var wire 1 . branch $end
$var wire 3 2 funct3 [2:0] $end
$var wire 1 3 funct7 $end
$var wire 2 4 inmSrc [1:0] $end
$var wire 1 , memWrite $end
$var wire 7 5 op [6:0] $end
$var wire 1 * pcSrc $end
$var wire 1 ) regWrite $end
$var wire 2 6 resSrc [1:0] $end
$var wire 1 & zero $end
$var wire 2 7 resSrc_int [1:0] $end
$var wire 1 8 regWrite_int $end
$var wire 1 9 memWrite_int $end
$var wire 2 : inmSrc_int [1:0] $end
$var wire 1 ; branch_int $end
$var wire 1 < aluSrc_int $end
$var wire 2 = aluOp [1:0] $end
$var wire 3 > ALUcontrol [2:0] $end
$scope module alu_decoder $end
$var wire 3 ? f3 [2:0] $end
$var wire 1 3 f7 $end
$var wire 2 @ aluOp [1:0] $end
$var reg 3 A aluControl [2:0] $end
$upscope $end
$scope module main_decoder $end
$var wire 7 B op [6:0] $end
$var reg 2 C aluOp [1:0] $end
$var reg 1 < aluSrc $end
$var reg 1 ; branch $end
$var reg 2 D inmSrc [1:0] $end
$var reg 1 9 memWrite $end
$var reg 1 8 regWrite $end
$var reg 2 E resSrc [1:0] $end
$upscope $end
$upscope $end
$scope module data_path $end
$var wire 3 F ALUcontrol [2:0] $end
$var wire 1 / aluSrc $end
$var wire 1 . branch $end
$var wire 1 " clk $end
$var wire 2 G inmSrc [1:0] $end
$var wire 32 H instruction [31:0] $end
$var wire 1 , memWrite $end
$var wire 1 * pcSrc $end
$var wire 1 ) regWrite $end
$var wire 2 I resSrc [1:0] $end
$var wire 1 $ reset $end
$var wire 1 & zero $end
$var wire 32 J writeData [31:0] $end
$var wire 32 K srcB [31:0] $end
$var wire 32 L srcA [31:0] $end
$var wire 32 M signExtImm [31:0] $end
$var wire 32 N readData [31:0] $end
$var wire 32 O pcPlus4 [31:0] $end
$var wire 32 P pcNext [31:0] $end
$var wire 32 Q pc [31:0] $end
$var wire 32 R branchTarget [31:0] $end
$var wire 32 S aluResult [31:0] $end
$scope module alu $end
$var wire 3 T ALUControl [2:0] $end
$var wire 32 U srcB [31:0] $end
$var wire 32 V srcA [31:0] $end
$var reg 32 W result [31:0] $end
$var reg 1 & zero $end
$upscope $end
$scope module alu_src_mux $end
$var wire 1 / sel $end
$var wire 32 X salMux [31:0] $end
$var wire 32 Y e2 [31:0] $end
$var wire 32 Z e1 [31:0] $end
$upscope $end
$scope module branch_adder $end
$var wire 32 [ res [31:0] $end
$var wire 32 \ op2 [31:0] $end
$var wire 32 ] op1 [31:0] $end
$upscope $end
$scope module data_memory $end
$var wire 5 ^ addresDM [4:0] $end
$var wire 1 " clk $end
$var wire 1 , we $end
$var wire 32 _ wd [31:0] $end
$var reg 32 ` rd [31:0] $end
$upscope $end
$scope module pc_increment $end
$var wire 32 a op2 [31:0] $end
$var wire 32 b res [31:0] $end
$var wire 32 c op1 [31:0] $end
$upscope $end
$scope module pc_mux $end
$var wire 32 d e1 [31:0] $end
$var wire 32 e e2 [31:0] $end
$var wire 1 * sel $end
$var wire 32 f salMux [31:0] $end
$upscope $end
$scope module pc_reg $end
$var wire 1 " clk $end
$var wire 32 g pcNext [31:0] $end
$var wire 1 $ reset $end
$var reg 32 h pc [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 1 " clk $end
$var wire 5 i rd [4:0] $end
$var wire 32 j readData1 [31:0] $end
$var wire 32 k readData2 [31:0] $end
$var wire 5 l rs1 [4:0] $end
$var wire 5 m rs2 [4:0] $end
$var wire 1 ) we $end
$var wire 32 n writeData [31:0] $end
$var integer 32 o i [31:0] $end
$upscope $end
$scope module sign_ext $end
$var wire 25 p inm [24:0] $end
$var wire 2 q src [1:0] $end
$var reg 32 r inmExt [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 r
b0 q
b0 p
b100000 o
b0 n
b0 m
b0 l
b0 k
b0 j
b0 i
b0 h
b100 g
b100 f
b0 e
b100 d
b0 c
b100 b
b100 a
bx `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b100 P
b100 O
bx N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
0<
0;
b0 :
09
08
b0 7
b0 6
b0 5
b0 4
03
b0 2
b0 1
b0 0
0/
0.
b0 -
0,
b0 +
0*
0)
b0 (
b0 '
1&
b0 %
1$
b0 #
0"
b0 !
$end
#5000
1"
#10000
b1 ^
0&
b1 0
b1 S
b1 W
b1 '
b1 J
b1 U
b1 X
b1 n
b1 (
b1 6
b1 I
b1 7
b1 E
1/
1<
1)
18
b1 R
b1 [
b1 e
b1 M
b1 Y
b1 \
b1 r
b11 5
b11 B
b1 m
b101 i
b10000000000101 p
0"
b100000000001010000011 #
b100000000001010000011 %
b100000000001010000011 H
0$
#15000
b1000 P
b1000 f
b1000 g
b1000 O
b1000 b
b1000 d
b101 R
b101 [
b101 e
b100 !
b100 +
b100 Q
b100 ]
b100 c
b100 h
1"
#20000
b1 ^
b1 0
b1 S
b1 W
b1 '
b1 J
b1 U
b1 X
b1 n
1,
19
b1 -
b1 4
b1 G
b1 q
b1 :
b1 D
bx (
bx 6
bx I
bx 7
bx E
1/
1<
0)
08
b101 R
b101 [
b101 e
b1 M
b1 Y
b1 \
b1 r
b100011 5
b100011 B
b10 2
b10 ?
b10 m
b10 i
b100000001000010 p
0"
b1000000010000100100011 #
b1000000010000100100011 %
b1000000010000100100011 H
#25000
b0 N
b0 `
b1100 P
b1100 f
b1100 g
b1100 O
b1100 b
b1100 d
b1001 R
b1001 [
b1001 e
b1000 !
b1000 +
b1000 Q
b1000 ]
b1000 c
b1000 h
1"
#30000
bx N
bx `
b0 ^
1&
b0 0
b0 S
b0 W
b0 '
b0 J
b0 U
b0 X
b0 n
b10 =
b10 @
b10 C
1)
18
b0 (
b0 6
b0 I
b0 7
b0 E
0,
09
0/
0<
bx -
bx 4
bx G
bx q
bx :
bx D
b1000 R
b1000 [
b1000 e
b0 M
b0 Y
b0 \
b0 r
b110011 5
b110011 B
b0 2
b0 ?
b1 m
b11 i
b10000000000011 p
0"
b100000000000110110011 #
b100000000000110110011 %
b100000000000110110011 H
#35000
b10000 P
b10000 f
b10000 g
b10000 O
b10000 b
b10000 d
b1100 R
b1100 [
b1100 e
b1100 !
b1100 +
b1100 Q
b1100 ]
b1100 c
b1100 h
1"
#40000
1*
b1 1
b1 >
b1 A
b1 F
b1 T
b10000 R
b10000 [
b10000 e
b100 M
b100 Y
b100 \
b100 r
1.
1;
b1 =
b1 @
b1 C
b10 -
b10 4
b10 G
b10 q
b10 :
b10 D
0)
08
b1100011 5
b1100011 B
b1 l
b0 m
b0 i
b100000000 p
0"
b1000000001100011 #
b1000000001100011 %
b1000000001100011 H
#45000
b10100 P
b10100 f
b10100 g
b10100 O
b10100 b
b10100 d
b10100 R
b10100 [
b10100 e
b10000 !
b10000 +
b10000 Q
b10000 ]
b10000 c
b10000 h
1"
#50000
0"
